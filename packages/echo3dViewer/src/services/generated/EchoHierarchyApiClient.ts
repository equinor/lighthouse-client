/* tslint:disable -- auto generated */
/* eslint-disable -- auto generated */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IDataMaintenanceClient {
    /**
     * @param body (optional)
     * @return Success
     */
    triggerMaintenanceOfHierarchyCollection(body?: string | undefined): Promise<void>;
}

export class DataMaintenanceClient implements IDataMaintenanceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://';
    }

    /**
     * @param body (optional)
     * @return Success
     */
    triggerMaintenanceOfHierarchyCollection(
        body?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<void> {
        let url_ = this.baseUrl + '/api/v2/maintenance/hierarchy-store-sqlite';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTriggerMaintenanceOfHierarchyCollection(_response);
        });
    }

    protected processTriggerMaintenanceOfHierarchyCollection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IDataMaintenanceControllerV3Client {
    /**
     * @param body (optional)
     * @return Success
     */
    getCollectionExistsV3(containerName: string, body?: string | undefined): Promise<void>;
}

export class DataMaintenanceControllerV3Client implements IDataMaintenanceControllerV3Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://';
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getCollectionExistsV3(
        containerName: string,
        body?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<void> {
        let url_ = this.baseUrl + '/api/v3/maintenance/{containerName}';
        if (containerName === undefined || containerName === null)
            throw new Error("The parameter 'containerName' must be defined.");
        url_ = url_.replace('{containerName}', encodeURIComponent('' + containerName));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCollectionExistsV3(_response);
        });
    }

    protected processGetCollectionExistsV3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IHierarchyClient {
    /**
     * @return Success
     */
    getHierarchyExists(collection: string): Promise<boolean>;

    /**
     * @return Success
     */
    getNodeByNodeId(collection: string, id: number): Promise<HierarchyNodeModel>;

    /**
     * Returns the current node, and all ancestor nodes in a list.
    The current node will be item 0, and the root will be the last item.
     * @return Success
     */
    getAncestorNodesOfNodeId(collection: string, id: number): Promise<HierarchyNodeModelListResult>;

    /**
     * Get a nodes path by its id.
     * @return Success
     */
    getNodePathByNodeId(collection: string, id: number): Promise<StringListResult>;

    /**
     * Get all root-nodes.
     * @return Success
     */
    getTopNodes(collection: string): Promise<HierarchyNodeModelListResult>;

    /**
     * @return Success
     */
    findLeafNodeIdsByTopNodeId(collection: string, topNodeId: number): Promise<UInt32ListResult>;

    /**
     * @param body (optional)
     * @return Success
     */
    findLeafNodeIdsByTopNodeIdsBatch(collection: string, body?: number[] | undefined): Promise<UInt32ListResult>;

    /**
     * @param limit (optional)
     * @return Success
     */
    listTags(collection: string, limit?: number | undefined): Promise<string[]>;

    /**
     * @param body (optional)
     * @return Success
     */
    getNodesByName(collection: string, body?: string | undefined): Promise<HierarchyNodeModelListResult>;

    /**
     * @return Success
     */
    listLeafNodeIdsByProjectNo(collection: string, projectNo: string): Promise<number[]>;

    /**
     * @param body (optional)
     * @return Success
     */
    getNodeByPath(collection: string, body?: string[] | undefined): Promise<HierarchyNodeModel>;

    /**
     * Get the closest tag (This node, or ancestor).
            
    If the NodeId has no tag this returns null.
     * @return Success
     */
    getTagNodeByNodeId(collection: string, id: number): Promise<HierarchyNodeModel>;

    /**
     * @param limit (optional)
     * @param body (optional)
     * @return Success
     */
    findNodesByTagStartsWith(
        collection: string,
        limit?: number | undefined,
        body?: string | undefined
    ): Promise<HierarchyNodeModelListResult>;

    /**
     * @param limit (optional)
     * @param body (optional)
     * @return Success
     */
    findNodesByTagContains(
        collection: string,
        limit?: number | undefined,
        body?: string | undefined
    ): Promise<HierarchyNodeModelListResult>;

    /**
     * @param limit (optional)
     * @param body (optional)
     * @return Success
     */
    findNodesByNameStartsWith(
        collection: string,
        limit?: number | undefined,
        body?: string | undefined
    ): Promise<HierarchyNodeModelListResult>;

    /**
     * @param limit (optional)
     * @param body (optional)
     * @return Success
     */
    findNodesByNameContains(
        collection: string,
        limit?: number | undefined,
        body?: string | undefined
    ): Promise<HierarchyNodeModelListResult>;

    /**
     * Batch method to retrieve multiple nodes by their nodeId.
     * @param body (optional)
     * @return Success
     */
    findNodesByNodeIds(collection: string, body?: number[] | undefined): Promise<HierarchyNodeModelListResult>;

    /**
     * @param body (optional)
     * @return Success
     */
    findNodesByTagList(collection: string, body?: string[] | undefined): Promise<HierarchyNodeModelListResult>;

    /**
     * Find all leaf-nodes, and group them by their origin tag.
     * @param body (optional)
     * @return Success
     */
    findLeafNodesByTagList(collection: string, body?: string[] | undefined): Promise<NodeWithLeafNodesListResult>;

    /**
     * @param body (optional)
     * @return Success
     */
    findLeafNodesByTag(collection: string, body?: string | undefined): Promise<UInt32ListResult>;

    /**
     * Returns the tags found in the database.
            
    Can be used to check if any tags are existing in the database.
     * @param body (optional) 
     * @return Success
     */
    findExistingTagsByTags(collection: string, body?: string[] | undefined): Promise<string[]>;

    /**
     * @return Success
     */
    listSystems(collection: string): Promise<string[]>;

    /**
     * @return Success
     */
    listProjects(collection: string): Promise<string[]>;

    /**
     * @param limit (optional)
     * @return Success
     */
    listTagsInSystem(collection: string, systemCode: string, limit?: number | undefined): Promise<StringListResult>;

    /**
     * Get All nodes matching system.
            
    Consider if you only need the leaf nodes. See: M:Web.Application.Controllers.HierarchyController.GetLeafNodeIdsInSystemAsync(System.String,System.String)
     * @return Success
     */
    getNodesBySystem(collection: string, systemCode: string): Promise<HierarchyNodeModelListResult>;

    /**
     * Get all leaf nodes matching system.
            
    Consider if you only need the leaf node Ids. See: M:Web.Application.Controllers.HierarchyController.GetLeafNodeIdsInSystemAsync(System.String,System.String)
     * @return Success
     */
    getLeafNodesBySystem(collection: string, systemCode: string): Promise<HierarchyNodeModelListResult>;

    /**
     * @return Success
     */
    getLeafNodeIdsBySystem(collection: string, systemCode: string): Promise<UInt32ListResult>;

    /**
     * @return Success
     */
    getIsHierarchyNumericalNodeIds(collection: string): Promise<boolean>;

    /**
     * @param refNo (optional)
     * @return Success
     */
    getNodesByRefNo(collection: string, refNo?: string[] | undefined): Promise<HierarchyNodeModel[]>;

    /**
     * Get Nodes by RefNo in Batch (Supports longer lists of RefNos)
     * @param body (optional)
     * @return Success
     */
    findNodesByRefNoBatch(collection: string, body?: string[] | undefined): Promise<HierarchyNodeModel[]>;

    /**
     * @param refNo (optional)
     * @return Success
     */
    getNodeIdsByRefNos(collection: string, refNo?: string[] | undefined): Promise<number[]>;

    /**
     * Batch retrieve nodeIds by a list of RefNos.
     * @param body (optional) A list of RefNos
     * @return Success
     */
    getNodeIdsByRefNosBatch(collection: string, body?: string[] | undefined): Promise<number[]>;

    /**
     * @return Success
     */
    listPdmsKeys(collection: string): Promise<string[]>;

    /**
     * @param pdmsKey (optional)
     * @return Success
     */
    listPdmsValuesByPdmsKey(collection: string, pdmsKey?: string | undefined): Promise<string[]>;

    /**
     * @param pdmsKey (optional)
     * @param pdmsValue (optional)
     * @return Success
     */
    listNodesMatchingPdmsKeyValuePair(
        collection: string,
        pdmsKey?: string | undefined,
        pdmsValue?: string | undefined
    ): Promise<HierarchyNodeModel[]>;

    /**
     * @param pdmsKey (optional)
     * @param pdmsValue (optional)
     * @return Success
     */
    listNodeIdsMatchingPdmsKeyValuePair(
        collection: string,
        pdmsKey?: string | undefined,
        pdmsValue?: string | undefined
    ): Promise<number[]>;
}

export class HierarchyClient implements IHierarchyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://';
    }

    /**
     * @return Success
     */
    getHierarchyExists(collection: string, signal?: AbortSignal | undefined): Promise<boolean> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/exists';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHierarchyExists(_response);
        });
    }

    protected processGetHierarchyExists(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getNodeByNodeId(collection: string, id: number, signal?: AbortSignal | undefined): Promise<HierarchyNodeModel> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/id/{id}';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodeByNodeId(_response);
        });
    }

    protected processGetNodeByNodeId(response: Response): Promise<HierarchyNodeModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModel.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModel>(<any>null);
    }

    /**
     * Returns the current node, and all ancestor nodes in a list.
    The current node will be item 0, and the root will be the last item.
     * @return Success
     */
    getAncestorNodesOfNodeId(
        collection: string,
        id: number,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/id/{id}/hierarchy';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAncestorNodesOfNodeId(_response);
        });
    }

    protected processGetAncestorNodesOfNodeId(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * Get a nodes path by its id.
     * @return Success
     */
    getNodePathByNodeId(collection: string, id: number, signal?: AbortSignal | undefined): Promise<StringListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/id/{id}/hierarchyPath';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodePathByNodeId(_response);
        });
    }

    protected processGetNodePathByNodeId(response: Response): Promise<StringListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = StringListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringListResult>(<any>null);
    }

    /**
     * Get all root-nodes.
     * @return Success
     */
    getTopNodes(collection: string, signal?: AbortSignal | undefined): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/topNodes';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTopNodes(_response);
        });
    }

    protected processGetTopNodes(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * @return Success
     */
    findLeafNodeIdsByTopNodeId(
        collection: string,
        topNodeId: number,
        signal?: AbortSignal | undefined
    ): Promise<UInt32ListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/topNode/{topNodeId}/leafNodes/ids';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (topNodeId === undefined || topNodeId === null)
            throw new Error("The parameter 'topNodeId' must be defined.");
        url_ = url_.replace('{topNodeId}', encodeURIComponent('' + topNodeId));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeafNodeIdsByTopNodeId(_response);
        });
    }

    protected processFindLeafNodeIdsByTopNodeId(response: Response): Promise<UInt32ListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UInt32ListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<UInt32ListResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    findLeafNodeIdsByTopNodeIdsBatch(
        collection: string,
        body?: number[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<UInt32ListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/topNodes/leafNodes/ids';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeafNodeIdsByTopNodeIdsBatch(_response);
        });
    }

    protected processFindLeafNodeIdsByTopNodeIdsBatch(response: Response): Promise<UInt32ListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UInt32ListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<UInt32ListResult>(<any>null);
    }

    /**
     * @param limit (optional)
     * @return Success
     */
    listTags(collection: string, limit?: number | undefined, signal?: AbortSignal | undefined): Promise<string[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/tag?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListTags(_response);
        });
    }

    protected processListTags(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getNodesByName(
        collection: string,
        body?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/name';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodesByName(_response);
        });
    }

    protected processGetNodesByName(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * @return Success
     */
    listLeafNodeIdsByProjectNo(
        collection: string,
        projectNo: string,
        signal?: AbortSignal | undefined
    ): Promise<number[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/project/{projectNo}';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (projectNo === undefined || projectNo === null)
            throw new Error("The parameter 'projectNo' must be defined.");
        url_ = url_.replace('{projectNo}', encodeURIComponent('' + projectNo));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListLeafNodeIdsByProjectNo(_response);
        });
    }

    protected processListLeafNodeIdsByProjectNo(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    getNodeByPath(
        collection: string,
        body?: string[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModel> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/path';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodeByPath(_response);
        });
    }

    protected processGetNodeByPath(response: Response): Promise<HierarchyNodeModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModel.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModel>(<any>null);
    }

    /**
     * Get the closest tag (This node, or ancestor).
            
    If the NodeId has no tag this returns null.
     * @return Success
     */
    getTagNodeByNodeId(collection: string, id: number, signal?: AbortSignal | undefined): Promise<HierarchyNodeModel> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/id/{id}/tagNode';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTagNodeByNodeId(_response);
        });
    }

    protected processGetTagNodeByNodeId(response: Response): Promise<HierarchyNodeModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModel.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModel>(<any>null);
    }

    /**
     * @param limit (optional)
     * @param body (optional)
     * @return Success
     */
    findNodesByTagStartsWith(
        collection: string,
        limit?: number | undefined,
        body?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/tag/startsWith?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNodesByTagStartsWith(_response);
        });
    }

    protected processFindNodesByTagStartsWith(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * @param limit (optional)
     * @param body (optional)
     * @return Success
     */
    findNodesByTagContains(
        collection: string,
        limit?: number | undefined,
        body?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/tag/contains?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNodesByTagContains(_response);
        });
    }

    protected processFindNodesByTagContains(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * @param limit (optional)
     * @param body (optional)
     * @return Success
     */
    findNodesByNameStartsWith(
        collection: string,
        limit?: number | undefined,
        body?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/name/startsWith?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNodesByNameStartsWith(_response);
        });
    }

    protected processFindNodesByNameStartsWith(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * @param limit (optional)
     * @param body (optional)
     * @return Success
     */
    findNodesByNameContains(
        collection: string,
        limit?: number | undefined,
        body?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/name/contains?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNodesByNameContains(_response);
        });
    }

    protected processFindNodesByNameContains(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * Batch method to retrieve multiple nodes by their nodeId.
     * @param body (optional)
     * @return Success
     */
    findNodesByNodeIds(
        collection: string,
        body?: number[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/ids';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNodesByNodeIds(_response);
        });
    }

    protected processFindNodesByNodeIds(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    findNodesByTagList(
        collection: string,
        body?: string[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/tags';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNodesByTagList(_response);
        });
    }

    protected processFindNodesByTagList(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * Find all leaf-nodes, and group them by their origin tag.
     * @param body (optional)
     * @return Success
     */
    findLeafNodesByTagList(
        collection: string,
        body?: string[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<NodeWithLeafNodesListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/tags/leafnodes';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeafNodesByTagList(_response);
        });
    }

    protected processFindLeafNodesByTagList(response: Response): Promise<NodeWithLeafNodesListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = NodeWithLeafNodesListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<NodeWithLeafNodesListResult>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    findLeafNodesByTag(
        collection: string,
        body?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<UInt32ListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/tag/leafnodes/id';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindLeafNodesByTag(_response);
        });
    }

    protected processFindLeafNodesByTag(response: Response): Promise<UInt32ListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UInt32ListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<UInt32ListResult>(<any>null);
    }

    /**
     * Returns the tags found in the database.
            
    Can be used to check if any tags are existing in the database.
     * @param body (optional) 
     * @return Success
     */
    findExistingTagsByTags(
        collection: string,
        body?: string[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<string[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/tag/exists/tags';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindExistingTagsByTags(_response);
        });
    }

    protected processFindExistingTagsByTags(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    listSystems(collection: string, signal?: AbortSignal | undefined): Promise<string[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/system';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListSystems(_response);
        });
    }

    protected processListSystems(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    listProjects(collection: string, signal?: AbortSignal | undefined): Promise<string[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/project';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListProjects(_response);
        });
    }

    protected processListProjects(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param limit (optional)
     * @return Success
     */
    listTagsInSystem(
        collection: string,
        systemCode: string,
        limit?: number | undefined,
        signal?: AbortSignal | undefined
    ): Promise<StringListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/tag/system/{systemCode}?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (systemCode === undefined || systemCode === null)
            throw new Error("The parameter 'systemCode' must be defined.");
        url_ = url_.replace('{systemCode}', encodeURIComponent('' + systemCode));
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListTagsInSystem(_response);
        });
    }

    protected processListTagsInSystem(response: Response): Promise<StringListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = StringListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<StringListResult>(<any>null);
    }

    /**
     * Get All nodes matching system.
            
    Consider if you only need the leaf nodes. See: M:Web.Application.Controllers.HierarchyController.GetLeafNodeIdsInSystemAsync(System.String,System.String)
     * @return Success
     */
    getNodesBySystem(
        collection: string,
        systemCode: string,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/system/{systemCode}';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (systemCode === undefined || systemCode === null)
            throw new Error("The parameter 'systemCode' must be defined.");
        url_ = url_.replace('{systemCode}', encodeURIComponent('' + systemCode));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodesBySystem(_response);
        });
    }

    protected processGetNodesBySystem(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * Get all leaf nodes matching system.
            
    Consider if you only need the leaf node Ids. See: M:Web.Application.Controllers.HierarchyController.GetLeafNodeIdsInSystemAsync(System.String,System.String)
     * @return Success
     */
    getLeafNodesBySystem(
        collection: string,
        systemCode: string,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModelListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/system/{systemCode}/leafnodes';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (systemCode === undefined || systemCode === null)
            throw new Error("The parameter 'systemCode' must be defined.");
        url_ = url_.replace('{systemCode}', encodeURIComponent('' + systemCode));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeafNodesBySystem(_response);
        });
    }

    protected processGetLeafNodesBySystem(response: Response): Promise<HierarchyNodeModelListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = HierarchyNodeModelListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModelListResult>(<any>null);
    }

    /**
     * @return Success
     */
    getLeafNodeIdsBySystem(
        collection: string,
        systemCode: string,
        signal?: AbortSignal | undefined
    ): Promise<UInt32ListResult> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/system/{systemCode}/leafnodes/ids';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (systemCode === undefined || systemCode === null)
            throw new Error("The parameter 'systemCode' must be defined.");
        url_ = url_.replace('{systemCode}', encodeURIComponent('' + systemCode));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeafNodeIdsBySystem(_response);
        });
    }

    protected processGetLeafNodeIdsBySystem(response: Response): Promise<UInt32ListResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UInt32ListResult.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<UInt32ListResult>(<any>null);
    }

    /**
     * @return Success
     */
    getIsHierarchyNumericalNodeIds(collection: string, signal?: AbortSignal | undefined): Promise<boolean> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/isNumericalNodeId';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIsHierarchyNumericalNodeIds(_response);
        });
    }

    protected processGetIsHierarchyNumericalNodeIds(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * @param refNo (optional)
     * @return Success
     */
    getNodesByRefNo(
        collection: string,
        refNo?: string[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModel[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/refNo?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (refNo === null) throw new Error("The parameter 'refNo' cannot be null.");
        else if (refNo !== undefined)
            refNo &&
                refNo.forEach((item) => {
                    url_ += 'refNo=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodesByRefNo(_response);
        });
    }

    protected processGetNodesByRefNo(response: Response): Promise<HierarchyNodeModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(HierarchyNodeModel.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModel[]>(<any>null);
    }

    /**
     * Get Nodes by RefNo in Batch (Supports longer lists of RefNos)
     * @param body (optional)
     * @return Success
     */
    findNodesByRefNoBatch(
        collection: string,
        body?: string[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModel[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/refNo';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNodesByRefNoBatch(_response);
        });
    }

    protected processFindNodesByRefNoBatch(response: Response): Promise<HierarchyNodeModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(HierarchyNodeModel.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModel[]>(<any>null);
    }

    /**
     * @param refNo (optional)
     * @return Success
     */
    getNodeIdsByRefNos(
        collection: string,
        refNo?: string[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<number[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/refNo/ids?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (refNo === null) throw new Error("The parameter 'refNo' cannot be null.");
        else if (refNo !== undefined)
            refNo &&
                refNo.forEach((item) => {
                    url_ += 'refNo=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodeIdsByRefNos(_response);
        });
    }

    protected processGetNodeIdsByRefNos(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }

    /**
     * Batch retrieve nodeIds by a list of RefNos.
     * @param body (optional) A list of RefNos
     * @return Success
     */
    getNodeIdsByRefNosBatch(
        collection: string,
        body?: string[] | undefined,
        signal?: AbortSignal | undefined
    ): Promise<number[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/node/refNo/ids';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json-patch+json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodeIdsByRefNosBatch(_response);
        });
    }

    protected processGetNodeIdsByRefNosBatch(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }

    /**
     * @return Success
     */
    listPdmsKeys(collection: string, signal?: AbortSignal | undefined): Promise<string[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/pdms/keys';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListPdmsKeys(_response);
        });
    }

    protected processListPdmsKeys(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param pdmsKey (optional)
     * @return Success
     */
    listPdmsValuesByPdmsKey(
        collection: string,
        pdmsKey?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<string[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/pdms/values?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (pdmsKey === null) throw new Error("The parameter 'pdmsKey' cannot be null.");
        else if (pdmsKey !== undefined) url_ += 'pdmsKey=' + encodeURIComponent('' + pdmsKey) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListPdmsValuesByPdmsKey(_response);
        });
    }

    protected processListPdmsValuesByPdmsKey(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param pdmsKey (optional)
     * @param pdmsValue (optional)
     * @return Success
     */
    listNodesMatchingPdmsKeyValuePair(
        collection: string,
        pdmsKey?: string | undefined,
        pdmsValue?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<HierarchyNodeModel[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/pdms/nodes?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (pdmsKey === null) throw new Error("The parameter 'pdmsKey' cannot be null.");
        else if (pdmsKey !== undefined) url_ += 'pdmsKey=' + encodeURIComponent('' + pdmsKey) + '&';
        if (pdmsValue === null) throw new Error("The parameter 'pdmsValue' cannot be null.");
        else if (pdmsValue !== undefined) url_ += 'pdmsValue=' + encodeURIComponent('' + pdmsValue) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListNodesMatchingPdmsKeyValuePair(_response);
        });
    }

    protected processListNodesMatchingPdmsKeyValuePair(response: Response): Promise<HierarchyNodeModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(HierarchyNodeModel.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<HierarchyNodeModel[]>(<any>null);
    }

    /**
     * @param pdmsKey (optional)
     * @param pdmsValue (optional)
     * @return Success
     */
    listNodeIdsMatchingPdmsKeyValuePair(
        collection: string,
        pdmsKey?: string | undefined,
        pdmsValue?: string | undefined,
        signal?: AbortSignal | undefined
    ): Promise<number[]> {
        let url_ = this.baseUrl + '/api/v2/hierarchy/{collection}/pdms/nodes/leafnodes?';
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace('{collection}', encodeURIComponent('' + collection));
        if (pdmsKey === null) throw new Error("The parameter 'pdmsKey' cannot be null.");
        else if (pdmsKey !== undefined) url_ += 'pdmsKey=' + encodeURIComponent('' + pdmsKey) + '&';
        if (pdmsValue === null) throw new Error("The parameter 'pdmsValue' cannot be null.");
        else if (pdmsValue !== undefined) url_ += 'pdmsValue=' + encodeURIComponent('' + pdmsValue) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListNodeIdsMatchingPdmsKeyValuePair(_response);
        });
    }

    protected processListNodeIdsMatchingPdmsKeyValuePair(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(item);
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }
}

export interface IStatusClient {
    /**
     * @return Success
     */
    getApiStatus(): Promise<string>;

    /**
     * @return Success
     */
    getOnlineAnonymous(): Promise<void>;
}

export class StatusClient implements IStatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://';
    }

    /**
     * @return Success
     */
    getApiStatus(signal?: AbortSignal | undefined): Promise<string> {
        let url_ = this.baseUrl + '/api/API';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiStatus(_response);
        });
    }

    protected processGetApiStatus(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    getOnlineAnonymous(signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + '/api/online';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {}
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOnlineAnonymous(_response);
        });
    }

    protected processGetOnlineAnonymous(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class HierarchyNodeModel implements IHierarchyNodeModel {
    id!: number;
    refNoDb?: number | undefined;
    refNoSequence?: number | undefined;
    name!: string;
    discipline?: string | undefined;
    fullPath!: string[];
    tag?: string | undefined;
    system?: string | undefined;
    topNodeId!: number;
    parentId?: number | undefined;
    pdmsData!: { [key: string]: string };
    childrenIds!: number[];
    aabb?: AabbModel | undefined;
    diagnosticInfo?: string | undefined;

    constructor(data?: IHierarchyNodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fullPath = [];
            this.pdmsData = {};
            this.childrenIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.refNoDb = _data['refNoDb'];
            this.refNoSequence = _data['refNoSequence'];
            this.name = _data['name'];
            this.discipline = _data['discipline'];
            if (Array.isArray(_data['fullPath'])) {
                this.fullPath = [] as any;
                for (let item of _data['fullPath']) this.fullPath!.push(item);
            }
            this.tag = _data['tag'];
            this.system = _data['system'];
            this.topNodeId = _data['topNodeId'];
            this.parentId = _data['parentId'];
            if (_data['pdmsData']) {
                this.pdmsData = {} as any;
                for (let key in _data['pdmsData']) {
                    if (_data['pdmsData'].hasOwnProperty(key)) (<any>this.pdmsData)![key] = _data['pdmsData'][key];
                }
            }
            if (Array.isArray(_data['childrenIds'])) {
                this.childrenIds = [] as any;
                for (let item of _data['childrenIds']) this.childrenIds!.push(item);
            }
            this.aabb = _data['aabb'] ? AabbModel.fromJS(_data['aabb']) : <any>undefined;
            this.diagnosticInfo = _data['diagnosticInfo'];
        }
    }

    static fromJS(data: any): HierarchyNodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new HierarchyNodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['refNoDb'] = this.refNoDb;
        data['refNoSequence'] = this.refNoSequence;
        data['name'] = this.name;
        data['discipline'] = this.discipline;
        if (Array.isArray(this.fullPath)) {
            data['fullPath'] = [];
            for (let item of this.fullPath) data['fullPath'].push(item);
        }
        data['tag'] = this.tag;
        data['system'] = this.system;
        data['topNodeId'] = this.topNodeId;
        data['parentId'] = this.parentId;
        if (this.pdmsData) {
            data['pdmsData'] = {};
            for (let key in this.pdmsData) {
                if (this.pdmsData.hasOwnProperty(key)) (<any>data['pdmsData'])[key] = this.pdmsData[key];
            }
        }
        if (Array.isArray(this.childrenIds)) {
            data['childrenIds'] = [];
            for (let item of this.childrenIds) data['childrenIds'].push(item);
        }
        data['aabb'] = this.aabb ? this.aabb.toJSON() : <any>undefined;
        data['diagnosticInfo'] = this.diagnosticInfo;
        return data;
    }
}

export interface IHierarchyNodeModel {
    id: number;
    refNoDb?: number | undefined;
    refNoSequence?: number | undefined;
    name: string;
    discipline?: string | undefined;
    fullPath: string[];
    tag?: string | undefined;
    system?: string | undefined;
    topNodeId: number;
    parentId?: number | undefined;
    pdmsData: { [key: string]: string };
    childrenIds: number[];
    aabb?: AabbModel | undefined;
    diagnosticInfo?: string | undefined;
}

export class HierarchyNodeModelListResult implements IHierarchyNodeModelListResult {
    results!: HierarchyNodeModel[];
    totalResults!: number;

    constructor(data?: IHierarchyNodeModelListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['results'])) {
                this.results = [] as any;
                for (let item of _data['results']) this.results!.push(HierarchyNodeModel.fromJS(item));
            }
            this.totalResults = _data['totalResults'];
        }
    }

    static fromJS(data: any): HierarchyNodeModelListResult {
        data = typeof data === 'object' ? data : {};
        let result = new HierarchyNodeModelListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data['results'] = [];
            for (let item of this.results) data['results'].push(item.toJSON());
        }
        data['totalResults'] = this.totalResults;
        return data;
    }
}

export interface IHierarchyNodeModelListResult {
    results: HierarchyNodeModel[];
    totalResults: number;
}

export class NodeWithLeafNodes implements INodeWithLeafNodes {
    parentNode!: SimpleNodeModel;
    leafNodes!: SimpleNodeModel[];

    constructor(data?: INodeWithLeafNodes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parentNode = new SimpleNodeModel();
            this.leafNodes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentNode = _data['parentNode'] ? SimpleNodeModel.fromJS(_data['parentNode']) : new SimpleNodeModel();
            if (Array.isArray(_data['leafNodes'])) {
                this.leafNodes = [] as any;
                for (let item of _data['leafNodes']) this.leafNodes!.push(SimpleNodeModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NodeWithLeafNodes {
        data = typeof data === 'object' ? data : {};
        let result = new NodeWithLeafNodes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['parentNode'] = this.parentNode ? this.parentNode.toJSON() : <any>undefined;
        if (Array.isArray(this.leafNodes)) {
            data['leafNodes'] = [];
            for (let item of this.leafNodes) data['leafNodes'].push(item.toJSON());
        }
        return data;
    }
}

export interface INodeWithLeafNodes {
    parentNode: SimpleNodeModel;
    leafNodes: SimpleNodeModel[];
}

export class NodeWithLeafNodesListResult implements INodeWithLeafNodesListResult {
    results!: NodeWithLeafNodes[];
    totalResults!: number;

    constructor(data?: INodeWithLeafNodesListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['results'])) {
                this.results = [] as any;
                for (let item of _data['results']) this.results!.push(NodeWithLeafNodes.fromJS(item));
            }
            this.totalResults = _data['totalResults'];
        }
    }

    static fromJS(data: any): NodeWithLeafNodesListResult {
        data = typeof data === 'object' ? data : {};
        let result = new NodeWithLeafNodesListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data['results'] = [];
            for (let item of this.results) data['results'].push(item.toJSON());
        }
        data['totalResults'] = this.totalResults;
        return data;
    }
}

export interface INodeWithLeafNodesListResult {
    results: NodeWithLeafNodes[];
    totalResults: number;
}

export class SimpleNodeModel implements ISimpleNodeModel {
    id!: number;
    refNoDb?: number | undefined;
    refNoSequence?: number | undefined;
    name!: string;
    discipline?: string | undefined;
    fullPath!: string[];
    tag?: string | undefined;
    system?: string | undefined;

    constructor(data?: ISimpleNodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fullPath = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.refNoDb = _data['refNoDb'];
            this.refNoSequence = _data['refNoSequence'];
            this.name = _data['name'];
            this.discipline = _data['discipline'];
            if (Array.isArray(_data['fullPath'])) {
                this.fullPath = [] as any;
                for (let item of _data['fullPath']) this.fullPath!.push(item);
            }
            this.tag = _data['tag'];
            this.system = _data['system'];
        }
    }

    static fromJS(data: any): SimpleNodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleNodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['refNoDb'] = this.refNoDb;
        data['refNoSequence'] = this.refNoSequence;
        data['name'] = this.name;
        data['discipline'] = this.discipline;
        if (Array.isArray(this.fullPath)) {
            data['fullPath'] = [];
            for (let item of this.fullPath) data['fullPath'].push(item);
        }
        data['tag'] = this.tag;
        data['system'] = this.system;
        return data;
    }
}

export interface ISimpleNodeModel {
    id: number;
    refNoDb?: number | undefined;
    refNoSequence?: number | undefined;
    name: string;
    discipline?: string | undefined;
    fullPath: string[];
    tag?: string | undefined;
    system?: string | undefined;
}

export class StringListResult implements IStringListResult {
    results!: string[];
    totalResults!: number;

    constructor(data?: IStringListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['results'])) {
                this.results = [] as any;
                for (let item of _data['results']) this.results!.push(item);
            }
            this.totalResults = _data['totalResults'];
        }
    }

    static fromJS(data: any): StringListResult {
        data = typeof data === 'object' ? data : {};
        let result = new StringListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data['results'] = [];
            for (let item of this.results) data['results'].push(item);
        }
        data['totalResults'] = this.totalResults;
        return data;
    }
}

export interface IStringListResult {
    results: string[];
    totalResults: number;
}

export class UInt32ListResult implements IUInt32ListResult {
    results!: number[];
    totalResults!: number;

    constructor(data?: IUInt32ListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['results'])) {
                this.results = [] as any;
                for (let item of _data['results']) this.results!.push(item);
            }
            this.totalResults = _data['totalResults'];
        }
    }

    static fromJS(data: any): UInt32ListResult {
        data = typeof data === 'object' ? data : {};
        let result = new UInt32ListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data['results'] = [];
            for (let item of this.results) data['results'].push(item);
        }
        data['totalResults'] = this.totalResults;
        return data;
    }
}

export interface IUInt32ListResult {
    results: number[];
    totalResults: number;
}

export class Vector3Model implements IVector3Model {
    x!: number;
    y!: number;
    z!: number;

    constructor(data?: IVector3Model) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data['x'];
            this.y = _data['y'];
            this.z = _data['z'];
        }
    }

    static fromJS(data: any): Vector3Model {
        data = typeof data === 'object' ? data : {};
        let result = new Vector3Model();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['x'] = this.x;
        data['y'] = this.y;
        data['z'] = this.z;
        return data;
    }
}

export interface IVector3Model {
    x: number;
    y: number;
    z: number;
}

export class AabbModel implements IAabbModel {
    min!: Vector3Model;
    max!: Vector3Model;

    constructor(data?: IAabbModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.min = new Vector3Model();
            this.max = new Vector3Model();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.min = _data['min'] ? Vector3Model.fromJS(_data['min']) : new Vector3Model();
            this.max = _data['max'] ? Vector3Model.fromJS(_data['max']) : new Vector3Model();
        }
    }

    static fromJS(data: any): AabbModel {
        data = typeof data === 'object' ? data : {};
        let result = new AabbModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['min'] = this.min ? this.min.toJSON() : <any>undefined;
        data['max'] = this.max ? this.max.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAabbModel {
    min: Vector3Model;
    max: Vector3Model;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
): any {
    if (result !== null && result !== undefined) throw result;
    else throw new ApiException(message, status, response, headers, null);
}
