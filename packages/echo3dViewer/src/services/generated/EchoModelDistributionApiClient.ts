/* tslint:disable -- autogenerated and thus ignored */
/* eslint-disable -- autogenerated and thus ignored */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IApiStatusClient {
    /**
     * If the model service is offline most of Echo 3D is not usable.
    This route can be used as a "Am I online" check in the Echo Clients, instead of "ping equinor.com" or similar.
     * @return Success
     */
    getApiStatusIsOnline(): Promise<void>;
}

export class ApiStatusClient implements IApiStatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://';
    }

    /**
     * If the model service is offline most of Echo 3D is not usable.
    This route can be used as a "Am I online" check in the Echo Clients, instead of "ping equinor.com" or similar.
     * @return Success
     */
    getApiStatusIsOnline(signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + '/api-status/online';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {}
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiStatusIsOnline(_response);
        });
    }

    protected processGetApiStatusIsOnline(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException('Not Found', status, _responseText, _headers, result404);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
                return;
            });
        } else {
            return response.text().then((_responseText) => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException('Error', status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export interface IModelAdminClient {
    /**
     * Post model data and retrieve metadata for performing upload
     * @param body (optional)
     * @return Success
     */
    addModelAndRetrieveUploadToken(body?: AssetMetadataDto | undefined): Promise<AssetUploadToken>;

    /**
     * Set the upload state for an uploadToken
     * @return Success
     */
    updateModelUploadCompleted(uploadTokenId: string, state: ModelStates): Promise<void>;
}

export class ModelAdminClient implements IModelAdminClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://';
    }

    /**
     * Post model data and retrieve metadata for performing upload
     * @param body (optional)
     * @return Success
     */
    addModelAndRetrieveUploadToken(
        body?: AssetMetadataDto | undefined,
        signal?: AbortSignal | undefined
    ): Promise<AssetUploadToken> {
        let url_ = this.baseUrl + '/admin/model';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json',
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddModelAndRetrieveUploadToken(_response);
        });
    }

    protected processAddModelAndRetrieveUploadToken(response: Response): Promise<AssetUploadToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException('Bad Request', status, _responseText, _headers, result400);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = AssetUploadToken.fromJS(resultData201);
                return result201;
            });
        } else {
            return response.text().then((_responseText) => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException('Error', status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Set the upload state for an uploadToken
     * @return Success
     */
    updateModelUploadCompleted(
        uploadTokenId: string,
        state: ModelStates,
        signal?: AbortSignal | undefined
    ): Promise<void> {
        let url_ = this.baseUrl + '/admin/model/{uploadTokenId}/{state}';
        if (uploadTokenId === undefined || uploadTokenId === null)
            throw new Error("The parameter 'uploadTokenId' must be defined.");
        url_ = url_.replace('{uploadTokenId}', encodeURIComponent('' + uploadTokenId));
        if (state === undefined || state === null) throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace('{state}', encodeURIComponent('' + state));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'POST',
            signal,
            headers: {}
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateModelUploadCompleted(_response);
        });
    }

    protected processUpdateModelUploadCompleted(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException('Bad Request', status, _responseText, _headers, result400);
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
                return;
            });
        } else {
            return response.text().then((_responseText) => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException('Error', status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export interface IModelsClient {
    /**
     * List all models available to the user, most recent versions only
     * @param artifactKind (optional)
     * @param artifactVersion (optional)
     * @param plantCode (optional)
     * @param plantSection (optional)
     * @return Success
     */
    listModels(
        artifactKind?: string | null | undefined,
        artifactVersion?: string | null | undefined,
        plantCode?: string | null | undefined,
        plantSection?: string | null | undefined
    ): Promise<AssetMetadataSimpleDto[]>;

    /**
     * Get a model by Id
     * @return Success
     */
    getModelById(id: number): Promise<AssetDownloadDto>;

    /**
     * Get a model by Id, including list of available files
     * @return Success
     */
    getModelFilesByModelId(id: number): Promise<AssetDownloadDto>;
}

export class ModelsClient implements IModelsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://';
    }

    /**
     * List all models available to the user, most recent versions only
     * @param artifactKind (optional)
     * @param artifactVersion (optional)
     * @param plantCode (optional)
     * @param plantSection (optional)
     * @return Success
     */
    listModels(
        artifactKind?: string | null | undefined,
        artifactVersion?: string | null | undefined,
        plantCode?: string | null | undefined,
        plantSection?: string | null | undefined,
        signal?: AbortSignal | undefined
    ): Promise<AssetMetadataSimpleDto[]> {
        let url_ = this.baseUrl + '/models?';
        if (artifactKind !== undefined && artifactKind !== null)
            url_ += 'artifactKind=' + encodeURIComponent('' + artifactKind) + '&';
        if (artifactVersion !== undefined && artifactVersion !== null)
            url_ += 'artifactVersion=' + encodeURIComponent('' + artifactVersion) + '&';
        if (plantCode !== undefined && plantCode !== null)
            url_ += 'plantCode=' + encodeURIComponent('' + plantCode) + '&';
        if (plantSection !== undefined && plantSection !== null)
            url_ += 'plantSection=' + encodeURIComponent('' + plantSection) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListModels(_response);
        });
    }

    protected processListModels(response: Response): Promise<AssetMetadataSimpleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200) result200!.push(AssetMetadataSimpleDto.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException('Not Found', status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException('Error', status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Get a model by Id
     * @return Success
     */
    getModelById(id: number, signal?: AbortSignal | undefined): Promise<AssetDownloadDto> {
        let url_ = this.baseUrl + '/models/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModelById(_response);
        });
    }

    protected processGetModelById(response: Response): Promise<AssetDownloadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AssetDownloadDto.fromJS(resultData200);
                return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException('Not Found', status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException('Error', status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * Get a model by Id, including list of available files
     * @return Success
     */
    getModelFilesByModelId(id: number, signal?: AbortSignal | undefined): Promise<AssetDownloadDto> {
        let url_ = this.baseUrl + '/models/{id}/files';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModelFilesByModelId(_response);
        });
    }

    protected processGetModelFilesByModelId(response: Response): Promise<AssetDownloadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AssetDownloadDto.fromJS(resultData200);
                return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException('Not Found', status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
                let resultdefault: any = null;
                let resultDatadefault = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                resultdefault = ProblemDetails.fromJS(resultDatadefault);
                return throwException('Error', status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export interface IRevealProxyClient {
    /**
     * For now this is a dummy
     * @return Success
     */
    getRevealRevision3d(projectId: string | null, modelId: number, revisionId: number): Promise<RevealRevision3D>;

    /**
     * Dummy implementation. The modelId is returned as the BlobId.
     * @param format (optional)
     * @return Success
     */
    getRevealRevisionOutputs(
        projectId: string | null,
        modelId: number,
        revisionId: number,
        format?: string | null | undefined
    ): Promise<RevealRevisionOutputs>;

    /**
     * @return Success
     */
    getFilesByProjectIdAndModelId(projectId: string | null, modelId: number, fileName: string | null): Promise<Stream>;
}

export class RevealProxyClient implements IRevealProxyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://';
    }

    /**
     * For now this is a dummy
     * @return Success
     */
    getRevealRevision3d(
        projectId: string | null,
        modelId: number,
        revisionId: number,
        signal?: AbortSignal | undefined
    ): Promise<RevealRevision3D> {
        let url_ = this.baseUrl + '/api/v1/projects/{projectId}/3d/models/{modelId}/revisions/{revisionId}';
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
        if (modelId === undefined || modelId === null) throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace('{modelId}', encodeURIComponent('' + modelId));
        if (revisionId === undefined || revisionId === null)
            throw new Error("The parameter 'revisionId' must be defined.");
        url_ = url_.replace('{revisionId}', encodeURIComponent('' + revisionId));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRevealRevision3d(_response);
        });
    }

    protected processGetRevealRevision3d(response: Response): Promise<RevealRevision3D> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RevealRevision3D.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<RevealRevision3D>(<any>null);
    }

    /**
     * Dummy implementation. The modelId is returned as the BlobId.
     * @param format (optional)
     * @return Success
     */
    getRevealRevisionOutputs(
        projectId: string | null,
        modelId: number,
        revisionId: number,
        format?: string | null | undefined,
        signal?: AbortSignal | undefined
    ): Promise<RevealRevisionOutputs> {
        let url_ = this.baseUrl + '/api/v1/projects/{projectId}/3d/models/{modelId}/revisions/{revisionId}/outputs?';
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
        if (modelId === undefined || modelId === null) throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace('{modelId}', encodeURIComponent('' + modelId));
        if (revisionId === undefined || revisionId === null)
            throw new Error("The parameter 'revisionId' must be defined.");
        url_ = url_.replace('{revisionId}', encodeURIComponent('' + revisionId));
        if (format !== undefined && format !== null) url_ += 'format=' + encodeURIComponent('' + format) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRevealRevisionOutputs(_response);
        });
    }

    protected processGetRevealRevisionOutputs(response: Response): Promise<RevealRevisionOutputs> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RevealRevisionOutputs.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<RevealRevisionOutputs>(<any>null);
    }

    /**
     * @return Success
     */
    getFilesByProjectIdAndModelId(
        projectId: string | null,
        modelId: number,
        fileName: string | null,
        signal?: AbortSignal | undefined
    ): Promise<Stream> {
        let url_ = this.baseUrl + '/api/v1/projects/{projectId}/3d/files/{modelId}/{fileName}';
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
        if (modelId === undefined || modelId === null) throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace('{modelId}', encodeURIComponent('' + modelId));
        if (fileName === undefined || fileName === null) throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace('{fileName}', encodeURIComponent('' + fileName));
        url_ = url_.replace(/[?&]$/, '');

        let options_ = <RequestInit>{
            method: 'GET',
            signal,
            headers: {
                Accept: 'text/plain'
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFilesByProjectIdAndModelId(_response);
        });
    }

    protected processGetFilesByProjectIdAndModelId(response: Response): Promise<Stream> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Stream.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Promise.resolve<Stream>(<any>null);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['type'] = this.type;
        data['title'] = this.title;
        data['status'] = this.status;
        data['detail'] = this.detail;
        data['instance'] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class AssetMetadataDto implements IAssetMetadataDto {
    artifactKind!: string;
    artifactFileFormatVersion!: string;
    plantCode!: string;
    installationCode?: string | undefined;
    platformSapId?: string | undefined;
    projectNameLabel!: string;
    platformNameLabel!: string;
    projectSectionId!: string;
    platformSectionId!: string;
    platformSectionLabel!: string;
    revisionNumber!: number;
    buildRunDateTimeIso8601!: Date;
    sourceModelUpdatedDateTimeIso8601!: Date;
    metadata?: { [key: string]: string } | undefined;

    constructor(data?: IAssetMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.artifactKind = _data['artifactKind'];
            this.artifactFileFormatVersion = _data['artifactFileFormatVersion'];
            this.plantCode = _data['plantCode'];
            this.installationCode = _data['installationCode'];
            this.platformSapId = _data['platformSapId'];
            this.projectNameLabel = _data['projectNameLabel'];
            this.platformNameLabel = _data['platformNameLabel'];
            this.projectSectionId = _data['projectSectionId'];
            this.platformSectionId = _data['platformSectionId'];
            this.platformSectionLabel = _data['platformSectionLabel'];
            this.revisionNumber = _data['revisionNumber'];
            this.buildRunDateTimeIso8601 = _data['buildRunDateTimeIso8601']
                ? new Date(_data['buildRunDateTimeIso8601'].toString())
                : <any>undefined;
            this.sourceModelUpdatedDateTimeIso8601 = _data['sourceModelUpdatedDateTimeIso8601']
                ? new Date(_data['sourceModelUpdatedDateTimeIso8601'].toString())
                : <any>undefined;
            if (_data['metadata']) {
                this.metadata = {} as any;
                for (let key in _data['metadata']) {
                    if (_data['metadata'].hasOwnProperty(key)) (<any>this.metadata)![key] = _data['metadata'][key];
                }
            }
        }
    }

    static fromJS(data: any): AssetMetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['artifactKind'] = this.artifactKind;
        data['artifactFileFormatVersion'] = this.artifactFileFormatVersion;
        data['plantCode'] = this.plantCode;
        data['installationCode'] = this.installationCode;
        data['platformSapId'] = this.platformSapId;
        data['projectNameLabel'] = this.projectNameLabel;
        data['platformNameLabel'] = this.platformNameLabel;
        data['projectSectionId'] = this.projectSectionId;
        data['platformSectionId'] = this.platformSectionId;
        data['platformSectionLabel'] = this.platformSectionLabel;
        data['revisionNumber'] = this.revisionNumber;
        data['buildRunDateTimeIso8601'] = this.buildRunDateTimeIso8601
            ? this.buildRunDateTimeIso8601.toISOString()
            : <any>undefined;
        data['sourceModelUpdatedDateTimeIso8601'] = this.sourceModelUpdatedDateTimeIso8601
            ? this.sourceModelUpdatedDateTimeIso8601.toISOString()
            : <any>undefined;
        if (this.metadata) {
            data['metadata'] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key)) (<any>data['metadata'])[key] = this.metadata[key];
            }
        }
        return data;
    }
}

export interface IAssetMetadataDto {
    artifactKind: string;
    artifactFileFormatVersion: string;
    plantCode: string;
    installationCode?: string | undefined;
    platformSapId?: string | undefined;
    projectNameLabel: string;
    platformNameLabel: string;
    projectSectionId: string;
    platformSectionId: string;
    platformSectionLabel: string;
    revisionNumber: number;
    buildRunDateTimeIso8601: Date;
    sourceModelUpdatedDateTimeIso8601: Date;
    metadata?: { [key: string]: string } | undefined;
}

export class AssetUploadToken implements IAssetUploadToken {
    requestVerified?: boolean;
    uploadDestination?: string | undefined;
    uploadToken?: string | undefined;
    validationResult?: string | undefined;
    readonly filesPrefix?: string | undefined;

    constructor(data?: IAssetUploadToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestVerified = _data['requestVerified'];
            this.uploadDestination = _data['uploadDestination'];
            this.uploadToken = _data['uploadToken'];
            this.validationResult = _data['validationResult'];
            (<any>this).filesPrefix = _data['filesPrefix'];
        }
    }

    static fromJS(data: any): AssetUploadToken {
        data = typeof data === 'object' ? data : {};
        let result = new AssetUploadToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['requestVerified'] = this.requestVerified;
        data['uploadDestination'] = this.uploadDestination;
        data['uploadToken'] = this.uploadToken;
        data['validationResult'] = this.validationResult;
        data['filesPrefix'] = this.filesPrefix;
        return data;
    }
}

export interface IAssetUploadToken {
    requestVerified?: boolean;
    uploadDestination?: string | undefined;
    uploadToken?: string | undefined;
    validationResult?: string | undefined;
    filesPrefix?: string | undefined;
}

export type ModelStates = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;

export class AssetMetadataSimpleDto implements IAssetMetadataSimpleDto {
    id!: number;
    plantCode!: string;
    revisionNumber!: number;
    artifactKind!: string;
    artifactVersion!: string;
    blobContainer?: string | undefined;
    filesPrefix?: string | undefined;
    installationCode?: string | undefined;
    /** Describes when the Optimizer run was started. */
    buildRunDateTime!: Date;
    /** The last modified timestamp of the Source files.
This is often more important to users than when the build was started. */
    sourceModelUpdatedDateTime!: Date;
    projectNameLabel!: string;
    platformNameLabel!: string;
    projectSectionId!: string;
    platformSectionId!: string;
    platformSectionLabel!: string;
    hierarchyId!: string;

    constructor(data?: IAssetMetadataSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.plantCode = _data['plantCode'];
            this.revisionNumber = _data['revisionNumber'];
            this.artifactKind = _data['artifactKind'];
            this.artifactVersion = _data['artifactVersion'];
            this.blobContainer = _data['blobContainer'];
            this.filesPrefix = _data['filesPrefix'];
            this.installationCode = _data['installationCode'];
            this.buildRunDateTime = _data['buildRunDateTime']
                ? new Date(_data['buildRunDateTime'].toString())
                : <any>undefined;
            this.sourceModelUpdatedDateTime = _data['sourceModelUpdatedDateTime']
                ? new Date(_data['sourceModelUpdatedDateTime'].toString())
                : <any>undefined;
            this.projectNameLabel = _data['projectNameLabel'];
            this.platformNameLabel = _data['platformNameLabel'];
            this.projectSectionId = _data['projectSectionId'];
            this.platformSectionId = _data['platformSectionId'];
            this.platformSectionLabel = _data['platformSectionLabel'];
            this.hierarchyId = _data['hierarchyId'];
        }
    }

    static fromJS(data: any): AssetMetadataSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetMetadataSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['plantCode'] = this.plantCode;
        data['revisionNumber'] = this.revisionNumber;
        data['artifactKind'] = this.artifactKind;
        data['artifactVersion'] = this.artifactVersion;
        data['blobContainer'] = this.blobContainer;
        data['filesPrefix'] = this.filesPrefix;
        data['installationCode'] = this.installationCode;
        data['buildRunDateTime'] = this.buildRunDateTime ? this.buildRunDateTime.toISOString() : <any>undefined;
        data['sourceModelUpdatedDateTime'] = this.sourceModelUpdatedDateTime
            ? this.sourceModelUpdatedDateTime.toISOString()
            : <any>undefined;
        data['projectNameLabel'] = this.projectNameLabel;
        data['platformNameLabel'] = this.platformNameLabel;
        data['projectSectionId'] = this.projectSectionId;
        data['platformSectionId'] = this.platformSectionId;
        data['platformSectionLabel'] = this.platformSectionLabel;
        data['hierarchyId'] = this.hierarchyId;
        return data;
    }
}

export interface IAssetMetadataSimpleDto {
    id: number;
    plantCode: string;
    revisionNumber: number;
    artifactKind: string;
    artifactVersion: string;
    blobContainer?: string | undefined;
    filesPrefix?: string | undefined;
    installationCode?: string | undefined;
    /** Describes when the Optimizer run was started. */
    buildRunDateTime: Date;
    /** The last modified timestamp of the Source files.
This is often more important to users than when the build was started. */
    sourceModelUpdatedDateTime: Date;
    projectNameLabel: string;
    platformNameLabel: string;
    projectSectionId: string;
    platformSectionId: string;
    platformSectionLabel: string;
    hierarchyId: string;
}

export class AssetDownloadToken implements IAssetDownloadToken {
    downloadUrl?: string | undefined;
    downloadSasToken?: string | undefined;
    readonly filesPrefix?: string | undefined;
    readonly hierarchyId?: string | undefined;

    constructor(data?: IAssetDownloadToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data['downloadUrl'];
            this.downloadSasToken = _data['downloadSasToken'];
            (<any>this).filesPrefix = _data['filesPrefix'];
            (<any>this).hierarchyId = _data['hierarchyId'];
        }
    }

    static fromJS(data: any): AssetDownloadToken {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDownloadToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['downloadUrl'] = this.downloadUrl;
        data['downloadSasToken'] = this.downloadSasToken;
        data['filesPrefix'] = this.filesPrefix;
        data['hierarchyId'] = this.hierarchyId;
        return data;
    }
}

export interface IAssetDownloadToken {
    downloadUrl?: string | undefined;
    downloadSasToken?: string | undefined;
    filesPrefix?: string | undefined;
    hierarchyId?: string | undefined;
}

export class AssetDownloadDto implements IAssetDownloadDto {
    assetMetaData?: AssetMetadataDto;
    assetDownloadInfo?: AssetDownloadToken;
    files?: string[] | undefined;

    constructor(data?: IAssetDownloadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assetMetaData = _data['assetMetaData']
                ? AssetMetadataDto.fromJS(_data['assetMetaData'])
                : <any>undefined;
            this.assetDownloadInfo = _data['assetDownloadInfo']
                ? AssetDownloadToken.fromJS(_data['assetDownloadInfo'])
                : <any>undefined;
            if (Array.isArray(_data['files'])) {
                this.files = [] as any;
                for (let item of _data['files']) this.files!.push(item);
            }
        }
    }

    static fromJS(data: any): AssetDownloadDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDownloadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['assetMetaData'] = this.assetMetaData ? this.assetMetaData.toJSON() : <any>undefined;
        data['assetDownloadInfo'] = this.assetDownloadInfo ? this.assetDownloadInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.files)) {
            data['files'] = [];
            for (let item of this.files) data['files'].push(item);
        }
        return data;
    }
}

export interface IAssetDownloadDto {
    assetMetaData?: AssetMetadataDto;
    assetDownloadInfo?: AssetDownloadToken;
    files?: string[] | undefined;
}

export class RevisionCameraProperties implements IRevisionCameraProperties {
    target?: number[] | undefined;
    position?: number[] | undefined;

    constructor(data?: IRevisionCameraProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['target'])) {
                this.target = [] as any;
                for (let item of _data['target']) this.target!.push(item);
            }
            if (Array.isArray(_data['position'])) {
                this.position = [] as any;
                for (let item of _data['position']) this.position!.push(item);
            }
        }
    }

    static fromJS(data: any): RevisionCameraProperties {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionCameraProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.target)) {
            data['target'] = [];
            for (let item of this.target) data['target'].push(item);
        }
        if (Array.isArray(this.position)) {
            data['position'] = [];
            for (let item of this.position) data['position'].push(item);
        }
        return data;
    }
}

export interface IRevisionCameraProperties {
    target?: number[] | undefined;
    position?: number[] | undefined;
}

export type Revision3DStatus = 0 | 1 | 2 | 3;

export class RevealRevision3D implements IRevealRevision3D {
    id?: number;
    fileId?: number;
    published?: boolean;
    rotation?: number[] | undefined;
    camera?: RevisionCameraProperties;
    status?: Revision3DStatus;
    assetMappingCount?: number;
    createdTime?: Date;
    metadata?: { [key: string]: string } | undefined;

    constructor(data?: IRevealRevision3D) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.fileId = _data['fileId'];
            this.published = _data['published'];
            if (Array.isArray(_data['rotation'])) {
                this.rotation = [] as any;
                for (let item of _data['rotation']) this.rotation!.push(item);
            }
            this.camera = _data['camera'] ? RevisionCameraProperties.fromJS(_data['camera']) : <any>undefined;
            this.status = _data['status'];
            this.assetMappingCount = _data['assetMappingCount'];
            this.createdTime = _data['createdTime'] ? new Date(_data['createdTime'].toString()) : <any>undefined;
            if (_data['metadata']) {
                this.metadata = {} as any;
                for (let key in _data['metadata']) {
                    if (_data['metadata'].hasOwnProperty(key)) (<any>this.metadata)![key] = _data['metadata'][key];
                }
            }
        }
    }

    static fromJS(data: any): RevealRevision3D {
        data = typeof data === 'object' ? data : {};
        let result = new RevealRevision3D();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['fileId'] = this.fileId;
        data['published'] = this.published;
        if (Array.isArray(this.rotation)) {
            data['rotation'] = [];
            for (let item of this.rotation) data['rotation'].push(item);
        }
        data['camera'] = this.camera ? this.camera.toJSON() : <any>undefined;
        data['status'] = this.status;
        data['assetMappingCount'] = this.assetMappingCount;
        data['createdTime'] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        if (this.metadata) {
            data['metadata'] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key)) (<any>data['metadata'])[key] = this.metadata[key];
            }
        }
        return data;
    }
}

export interface IRevealRevision3D {
    id?: number;
    fileId?: number;
    published?: boolean;
    rotation?: number[] | undefined;
    camera?: RevisionCameraProperties;
    status?: Revision3DStatus;
    assetMappingCount?: number;
    createdTime?: Date;
    metadata?: { [key: string]: string } | undefined;
}

export class RevealBlobOutputMetadata implements IRevealBlobOutputMetadata {
    blobId?: number;
    format?: string | undefined;
    version?: number;

    constructor(data?: IRevealBlobOutputMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blobId = _data['blobId'];
            this.format = _data['format'];
            this.version = _data['version'];
        }
    }

    static fromJS(data: any): RevealBlobOutputMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new RevealBlobOutputMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['blobId'] = this.blobId;
        data['format'] = this.format;
        data['version'] = this.version;
        return data;
    }
}

export interface IRevealBlobOutputMetadata {
    blobId?: number;
    format?: string | undefined;
    version?: number;
}

export class RevealRevisionOutputs implements IRevealRevisionOutputs {
    readonly items?: RevealBlobOutputMetadata[] | undefined;

    constructor(data?: IRevealRevisionOutputs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['items'])) {
                (<any>this).items = [] as any;
                for (let item of _data['items']) (<any>this).items!.push(RevealBlobOutputMetadata.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RevealRevisionOutputs {
        data = typeof data === 'object' ? data : {};
        let result = new RevealRevisionOutputs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data['items'] = [];
            for (let item of this.items) data['items'].push(item.toJSON());
        }
        return data;
    }
}

export interface IRevealRevisionOutputs {
    items?: RevealBlobOutputMetadata[] | undefined;
}

export class Stream implements IStream {
    readonly canRead?: boolean;
    readonly canSeek?: boolean;
    readonly canTimeout?: boolean;
    readonly canWrite?: boolean;
    readonly length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canRead = _data['canRead'];
            (<any>this).canSeek = _data['canSeek'];
            (<any>this).canTimeout = _data['canTimeout'];
            (<any>this).canWrite = _data['canWrite'];
            (<any>this).length = _data['length'];
            this.position = _data['position'];
            this.readTimeout = _data['readTimeout'];
            this.writeTimeout = _data['writeTimeout'];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['canRead'] = this.canRead;
        data['canSeek'] = this.canSeek;
        data['canTimeout'] = this.canTimeout;
        data['canWrite'] = this.canWrite;
        data['length'] = this.length;
        data['position'] = this.position;
        data['readTimeout'] = this.readTimeout;
        data['writeTimeout'] = this.writeTimeout;
        return data;
    }
}

export interface IStream {
    canRead?: boolean;
    canSeek?: boolean;
    canTimeout?: boolean;
    canWrite?: boolean;
    length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
): any {
    if (result !== null && result !== undefined) throw result;
    else throw new ApiException(message, status, response, headers, null);
}
